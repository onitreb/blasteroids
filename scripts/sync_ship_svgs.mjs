import fs from "node:fs";
import path from "node:path";

const REPO_ROOT = process.cwd();
const SVG_DIR = path.join(REPO_ROOT, "assets/ships/svg");
const OUT_JSON = path.join(REPO_ROOT, "assets/ships/presets.json");
const OUT_DEFAULTS = path.join(REPO_ROOT, "src/engine/shipPresetDefaults.js");

const DEFAULT_IDS = {
  small: "fighter_needle",
  medium: "gunship_hammer",
  large: "carrier_bulwark",
};

function readText(p) {
  return fs.readFileSync(p, "utf8");
}

function writeJson(p, obj) {
  fs.writeFileSync(p, JSON.stringify(obj, null, 2) + "\n");
}

function attr(text, name) {
  const re = new RegExp(`\\b${name}\\s*=\\s*(\"([^\"]*)\"|'([^']*)')`, "i");
  const m = text.match(re);
  if (!m) return null;
  return m[2] ?? m[3] ?? null;
}

function extractPaths(svgText) {
  const paths = [];
  const re = /<path\b[^>]*?\bd\s*=\s*(?:"([^"]*)"|'([^']*)')[^>]*>/gi;
  let m;
  while ((m = re.exec(svgText))) {
    const d = (m[1] ?? m[2] ?? "").trim();
    if (d) paths.push(d);
  }
  return paths;
}

function parseEngines(text) {
  const s = String(text ?? "").trim();
  if (!s) return undefined;
  const engines = [];
  const parts = s.split(";").map((p) => p.trim()).filter(Boolean);
  for (const p of parts) {
    const nums = p.split(",").map((v) => Number(v.trim()));
    if (nums.length < 2) continue;
    const x = nums[0];
    const y = nums[1];
    const len = nums.length >= 3 ? nums[2] : 14;
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(len)) continue;
    engines.push({ x, y, len });
  }
  return engines.length ? engines : undefined;
}

function readPresetFromSvg(filePath) {
  const svg = readText(filePath);
  const id = attr(svg, "data-ship-id") || path.basename(filePath, ".svg");
  const tier = attr(svg, "data-tier") || "small";
  const label = attr(svg, "data-label") || id;
  const hullRadius = Number(attr(svg, "data-hull-radius") || 0);
  const svgScale = Number(attr(svg, "data-svg-scale") || 1);
  const mirrorX = attr(svg, "data-mirror-x");
  const engines = parseEngines(attr(svg, "data-engines"));
  const paths = extractPaths(svg);
  if (paths.length === 0) throw new Error(`No <path d="..."> found in ${filePath}`);

  const pathD = paths.join(" ").replace(/\s+/g, " ").trim();
  return {
    id,
    tier,
    label,
    hullRadius: Number.isFinite(hullRadius) && hullRadius > 0 ? hullRadius : undefined,
    svgScale: Number.isFinite(svgScale) && svgScale > 0 ? svgScale : 1,
    mirrorX: mirrorX === "1" || mirrorX === "true" ? true : undefined,
    engines,
    path: pathD,
  };
}

function main() {
  if (!fs.existsSync(SVG_DIR)) throw new Error(`Missing svg dir: ${SVG_DIR}`);
  const svgFiles = fs
    .readdirSync(SVG_DIR)
    .filter((f) => f.toLowerCase().endsWith(".svg"))
    .map((f) => path.join(SVG_DIR, f))
    .sort((a, b) => a.localeCompare(b));

  const presets = svgFiles.map(readPresetFromSvg);
  const payload = { version: 1, presets };
  writeJson(OUT_JSON, payload);

  const byId = new Map(presets.map((p) => [p.id, p]));
  const pick = (tierKey) => {
    const id = DEFAULT_IDS[tierKey];
    const p = byId.get(id);
    if (!p) throw new Error(`Missing default preset id "${id}" for tier "${tierKey}"`);
    return {
      id: p.id,
      path: p.path,
      hullRadius: p.hullRadius ?? null,
      svgScale: p.svgScale ?? 1,
      mirrorX: p.mirrorX ?? false,
      engines: p.engines ?? null,
    };
  };

  const defaults = {
    small: pick("small"),
    medium: pick("medium"),
    large: pick("large"),
  };

  const src =
    "// Auto-generated by `node scripts/sync_ship_svgs.mjs`.\n" +
    "// Do not hand-edit; edit `assets/ships/svg/*.svg` and re-sync.\n\n" +
    `export const DEFAULT_SHIP_SVGS = ${JSON.stringify(defaults, null, 2)};\n`;
  fs.writeFileSync(OUT_DEFAULTS, src);

  console.log(`[ship-sync] wrote ${presets.length} presets to ${OUT_JSON}`);
  console.log(`[ship-sync] wrote defaults to ${OUT_DEFAULTS}`);
}

main();
